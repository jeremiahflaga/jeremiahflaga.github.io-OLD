---
layout: page
title: 'Anti-résumé'
permalink: /resume/2019/anti-resume
published: true
---
<!-- 
<style>
  h2 {
    //color: #507988;
    color: #6a9fb5;
  }
</style>
 -->

<div class="float-right">
  <a href="/images/Jboy2017-Anti-Resume-Original.jpg">
    <img src="/images/Jboy2017-Anti-Resume-Small.jpg" title="Jboy Anti Resume Image" alt="Jboy Anti Resume Image" height="300" />
  </a>
</div>


> "People don't walk around with anti-résumés telling you what they have not studied or experienced (it's the job of their competitors to do that), but it would be nice if they did."
<br /><br />
> --- Nassim Nicholas Taleb <small>(from ["Why You Should Surround Yourself With More Books Than You'll Ever Have Time to Read"](https://www.inc.com/jessica-stillman/why-you-should-stop-feeling-bad-about-all-those-books-you-buy-dont-read.html?cid=sf01002&sr_share=facebook))</small>


<!-- 
You think having an anti-résumé will put me at a disadvantage? ...
-->

This anti-résumé (together with my [résumé](/resume/2019)) will help me find the best job that fits my current skillset, and it will help you in determining if I am fit for your team or not. That would be _win-win_ for me and you! :smile:



<!-- [I also think that antiresume matches with this idea of TDD, or writing tests] -->

<!-- 
<small>_(Note: I'm not a sexist. In the following section(s), I'm using the terms 'his', 'him', and 'he' to refer to any human being: male or female, old or young etc..)_</small>
-->



<h2 id="i-never-experienced-being-an-algorithmer">
  <strong>I never experienced being an Algorithmer</strong>
</h2>

In my [résumé](/resume/2019#im-an-initiate), I considered myself as an [**Initiate**](https://terencemcghee.com/FileStore/Tech/1D0C454A70AC3AEF01BB1BAAD94C8753.html#initiate), based on Terence McGhee's "Software Ninja Class Hierarchy". But I never experienced being an [**Algorithmer**](https://terencemcghee.com/FileStore/Tech/1D0C454A70AC3AEF01BB1BAAD94C8753.html#algorithmer), even though it is much lower than the Initiate in that hierarchy --- _I do not have special knowledge in higher mathematics_. My weak mathematics background is the reason why I concentrated on learning how to build what they call [line-of-business (LOB) applications](https://blogs.msdn.microsoft.com/dragoman/2007/07/19/what-is-a-lob-application/) (or what is called _"representational-transactional systems"_ [here](https://web.archive.org/web/20190109022046/https://aryehoffman.com/entry/classifying-software/)), because these things do not need lots of knowledge in mathematics.

But I can work with an Algorithmer, and I have high respect for an Algorithmer, because I would have liked to experience being an Algorithmer had I given the chance (education) to become one. And I believe that working with an Algorithmer will benefit me --- I believe that I will learn a lot from an Algorithmer. I'm hoping also that an Algorithmer will learn a lot from me, if I will be working with one.



<h2 id="not-an-expert-on-frameworks">
  <strong>I'm not an expert on frameworks</strong>
</h2>

> "... Here's a possible surprise for you. I am not going to recommend that you need to become an Entity Framework guru. Nope, just the opposite in fact. I am going to suggest that you allow the Entity Framework development team to be the gurus, and you just focus on your specific application. After all, your Core Domain is where you want to put your creative energies, not in becoming an expert in Entity Framework."
<br /><br />
> --- Vaughn Vernon <small>(from ["Modeling Aggregates with DDD and Entity Framework"](https://vaughnvernon.co/?p=879))</small>


You might say, _"What! Frameworks are the ones that make us do our work easily and fast! Why are you saying that being an expert on frameworks is not important?"_

Wait!... I am not saying that being an expert on frameworks is not important. What I am trying to say is that, in programming, there are more important things to focus on than being an expert on frameworks --- such as [separating the business rules from the other parts of the system](http://craftsmanshipcounts.com/policy-mechanism-preservation-business-value). The business rules in a system are not googleable, so I believe that it is very important to separate them so that it will be very easy to locate them when fixing bugs.

(I intend to someday become an expert on some frameworks of course.)

You might ask what my excuse is for not being an expert on frameworks...

My excuse is that frameworks change very often and I do not have all the time to catch up with all the changes. Also, many years ago in our school library, I read this from a book called "The Magic of Thinking Big" <sup id="footnote-indicator-1">[[1]](#footnote-1)</sup>:

> "It is more important to use your mind to think than use it as a warehouse for facts."
<br /><br />
> "The ability to know how to get information is more important than using the mind as a garage for facts"

Today, we already have [the] google [search engine] which can serve as our garage for facts. We have StackOverflow too! And we have documentations for the frameworks we are using that are readily available online.

I would rather spend my time learning about how to write clean and decoupled code, and learning about software architecture and design, and learning about the _domain_ of the project I am working on, than being an expert on frameworks. 

But like I said above, I'm still willing to read and study more about a specific framework when I think my job requires a deeper knowledge of that specific framework. :smile:



<h2 id="if-your-codebase-is-messy">
  <strong>If your codebase is messy...</strong>
</h2>

> The biggest obstacle to improvement in large codebases is the existing code. "Duh." you might say. But I'm not talking about how hard it is to work in difficult code; **I'm talking about what that code leads you to believe.**
<br /><br />
If you spend most of your day wading through ugly code, it's very easy to believe that it will always be ugly and that any little thing that you do to make it better is simply not worth it. You might think, "What does it matter whether I make this little peice nicer if 90 percent of the time I'll still be working with murky slime? Sure, I can make this piece better, but what will that do for me this afternoon? Tomorrow?"
<br /><br />
Well, if you look at it that way, I'd have to agree with you. Not much.
<br /><br />
**But if you consistently do these little improvements, your system will start to look significantly different over the course of a couple of months.** At some point, you'll come to work in the morning expecting to sink your hands into some slime and discover, "Huh, this code looks pretty good. It looks like someone was in here refactoring recently." At that point, when you feel the difference between good code and bad code in your gut, you are a changed person...
<br /><br />
 --- Michael Feathers (p. 75 of ["Working Effectively with Legacy Code"](https://www.bookdepository.com/Working-Effectively-with-Legacy-Code-Michael-Feathers/9780131177055?a_aid=jflaga))

I would love to work on new projects where I will have influence on the decisions about the structure of the project (or at least I know the reasons behind the chosen structure), and whose codebase is kept clean from the start.

But most software systems in existence today are in the _maintenance phase_. And I've seen systems in the maintenance phase whose codebase is very messy. It's so hard to work on such codebases, and I would love **_not_** to work on such codebases. I even thought to myself before that _"I will never work on any messy codebase again"_.

But my attitude towards messy codebases _somewhat_ changed after I read this from an article written by Jonathan Boccara (["The Right Attitude to Deal with Legacy Code"](https://simpleprogrammer.com/2017/03/01/deal-with-legacy-code/)):

> I think it is important to recognize that legacy code is not the enemy.
<br /><br />
In fact, in most cases, we're here thanks to legacy code. The early stages of a given project were where it started to grow, capture clients, build up financial interest, and establish a brand that inspired customers. All of this was done with code that may happen to still be around today and that still performs the functionalities that your customers liked you for in the first place. This is legacy code. As its name states, this is your legacy. **Without it you would probably not even be getting paid today.**

> "... **consider that the code you’re working on is your code. Even if you haven’t written it yourself**, and regardless of how good or bad you think it is, this is your code, and **you have responsibility over it**."

<!--
That will be hard to do --- owning the code that somebody else has written --- most especially if the code is messy and hard to work with.

If you intend me to work on messy codebases

And if I will work on such codebases, I can stay long working on it **only if** the current team involved in it are cleaning it up (or intends to clean it up) bit-by-bit as they work on it daily.
-->

Because of that, it's okay for me to be involved working on a legacy (or messy) codebase **on one condition**: If you are going to hire me to work on a messy codebase, I will stay working on it for a long time **_only if_** the current team involved in it (which will include me) are cleaning it up (or intends to clean it up) _bit-by-bit as they work on it daily_. :smile:

I'm not saying that I'm already an expert in cleaning messy codebases. I'm not. But I'm studying to be good at it too. And one of the reasons why I want to be part of a team who wants to keep their codebases clean is that I want to learn from them; I want to learn their techniques of cleaning up codebases; I hope they can also learn from me. Another reason why I want the codebases I will be working on as clean as I can make it is because I do not want the programmers who will inherit my codebase to [spit lots of WT*s](https://www.osnews.com/story/19266/wtfsm/) while working on it in the future. :grin: Another reason is because ["a well-crafted code base makes me happy to go to work every day"](https://verraes.net/2011/04/beautiful-code/). Another reason is [pride](https://medium.com/@kentbeck_7670/software-design-is-human-relationships-part-1-of-3-perspective-1bcd53855557). Another reason is because if I stay long working on a project, there might arise a problem someday which will be hard to solve, or will take very long to solve, if the codebase is messy.

Okay... That's my condition before I will agree to work on a messy codebase.

<!-- 
If you hire me to work on a messy codebase, and the team working on it does not care about it and does not have a plan of doing something to clean it up bit-by-bit, I will work on that project and with that team _only if_ you pay me a million pesos per month. :grin: :laughing:

I'm including this here in my anti-résumé because I noticed in my previous jobs that if a programming team does not have a common set of values (such as adhering to ["Always leave the codebase cleaner than you found it"](http://verraes.net/2011/04/beautiful-code/)) working on a project will become frustrating. And frustrated people will not be very productive.

And if I noticed that I'm not productive in my job, I feel ashamed and I tend to quit.
 -->


## **I'm introverted**

... Which means that I might be very silent on my first encounters with a person, but will start to speak up when I get comfortable working with that person. :smile:

But there are times where I tend to be not that silent even with people I do not know when the topic of a conversation is something I'm very interested in, such as programming.



## **I'm not (yet) very good with my spoken English**

English is not my native language. So for me, writing in English is easier than conversing using it, because when writing I have lots of time to think on what to write. When conversing using English I need to respond quickly and there is very little time to think. :smile:



## **I'm not very good with UIs (and UX)**

... <small>(have you noticed that I did not include CSS in my [résumé](/resume/2019)?)</small> But I managed to work on UIs in all of my previous works, so I believe I can still manage to work with UIs when I work with you.

If I will be working with a UI/UX designer, I believe that he will not be having a problem working with me because I _intend_ to decouple my code from the UI (if possible*), so that my code will _not_ be very affected by UI changes, and the UI will not be very affected by my code changes.

(*Please understand that if a codebase is a legacy codebase, and is messy, it might take time before the _coupling_ problem can be fixed --- if you want it to be fixed and if it is not beyond my capability to fix it.)



## **I have almost no experience deploying things**

... But a coleague of mine once said that it is just almost the same as clicking the build button in an IDE. 

So if I am tasked of deployment and no one else is to guide me, I will just google how to do it. :smile:


<!--
## **I only have basic knowledge about functional programming**

All I know about functional programming is that there is no assignment statements and that there is heavy use of recursion.
-->



## **I know nothing about estimating**

Today, perhaps the only method I have in mind to honestly estimate the time to be spent to finish a project is to do at least two of the most important features of the app, then use the time spent on those two features to estimate the time that will be spent on the whole project.

But even then, my estimates might still be far from accurate.


## **I have almost no knowledge about software security**

When it comes to security, I only know about SQL injection, and I know that it can be prevented by not using string concatenation when building SQL queries. But even though I know that using string concatenation is wrong when building SQL queries, I still do it sometimes --- when I'm tired or bored, and there is an existing code in the project that I can just copy-and-paste. :grinning: But if you already have a set of guildelines for coding which I need to follow, or you practice code review or pair programming, then this will not be a problem. 

<!-- And I will be happy to work with a teammate who will correct me if I do not follow correct guidelines. -->

Oh, I also know about _not_ storing passwords in plaintext, but instead hashing them before storing them. And I also know about not sending _forgotten passwords_ to users (because, of course, if we do not store passwords as plaintext, we will not know what password to send to them), but instead send them link to a form/resource that will let them change their passwords.

I also read in the past about Cross-site Scripting (XSS) and Cross-site Request Forgery (CSRF), but I have to review them to bring them back to mind.

<!-- 
but I already forgot what they are. All I know is that, to prevent these attacks in an ASP.NET MVC application, we only have to put a _specific_ Attribute in our Controller class or in a function inside a Controller class (I already forgot what that Attribute is), and that we must be cautious about the properties in our Model (or view model) that we expose to our users.
 -->

But I have a copy of the book ["Foundations of Security: What Every Programmer Needs to Know"](https://www.bookdepository.com/Foundations-Security-Christoph-Kern/9781590597842?a_aid=jflaga) (but I have read only some chapters from it). So if you need me to become familiar with software security when working at your company, I can start with this book (or with any material you can recommend me to consume).



<br />


### _**More next time...**_


<br />


**_Thank you for your time!_**


<br />



<!--

## **It's hard for me to stay long with a team who**

I cannot stay long with a team when I sense that it's members have the kind of attitude that sounds  like "I might not be the one to maintain this project, why should I care if its codebase is clean or not!"

Of course I understand that there are existing projects that are very messy already so that is't hard to clean it up.



## **I sometimes get frustrated when I know that something is wrong and I cannot do anything about it**

I will get frustrated sometimes (oftentimes perhaps) when I know that we can do better with things but the team are not doing anything about it.


I would be great if there is a kind of system where a programmer can be able to raise his concerns about the existing codebase if he thinks that there is something wrong in the codebase... and that we do something about it, or at least plan to do something about it... to fix it later... because if a team does not do this, it seems to me that we are being dishonest to our employer, and to our clients.



## **I sometimes think about justice when I see messy code...**

> "Let those who produced messy code be the ones to fix them. Don't give them another new project to start until they fix their mess!... Do you really want them to create another mess?"

Well, I am very bold in saying that because I never experienced being involved in a software project _from the very start of the project_. I only experienced working on software projects that are in the maintenance phase already.

So when I see code that looks like it was abandoned by their creators, I'm torn inside. --- _Why!?... Don't they care?_

But perhaps I should stop thinking like this. I should be [empathetic](http://chadfowler.com/2014/01/19/empathy.html) towards other programmers because I do not know what they have been through while working on the projects with messy codebase. Perhaps they had tight deadlines, and that is the reason why they did not give time cleaning up their mess.

Okay...

I think I can help in fixing messy software... But I'm not [Micheal Feathers](https://www.bookdepository.com/Working-Effectively-with-Legacy-Code-Michael-Feathers/9780131177055?a_aid=jflaga), so if the mess is very big already, you might need someone more skillful than me to help fix it. If the mess is still small, I might be able to help (I hope).



## **I sometimes get frustrated when I know that the codebase of the project I am working on is messy and I cannot do anything about it (and my teammates are not planning to do anything about it)**

> "Do unto others what you want others to do to you."

That's what Jesus said.

If you don't want to hear it from Jesus, hear it from Confucius who said something quite similar:

> "Do not do to others what you do not want others to do to you"

Our master programmers have their own version (or application) of this motto:

> "Always leave the campground cleaner than you found it."

They call that "The Boyscout Rule".

I want to live by that kind of rule. If 
-->


<!--
## **I intend to separate the business rules from the other parts of a software system**

Being influenced by people who promote DDD _(Note: I only know a little about DDD)_, and Clean Architecture, I am the kind of person who _would like to_ focus more on learning about the _domain_ of the business... and to focus on trying to model that domain instead on focusing on the specifics of the frameworks or libraries being used in the software system I am involved in.

If I am hired, I plan to spend at least half of my time (during the first few weeks) learning about the business and half of the time learning about the specific frameworks/libraries/technologies your team is using.

And if your domain is not googleable, or there are no books available to learn about it, then I might need _lots of guidance_ from my fellow programmers who are already familiar with the domain, or from the business people themselves, while learning about your domain.
-->

<!-- 

## **I work very well, even during trying hours, _only if_ there is rapid feedback from the system I am working on**

I'm a patient kind of man, I think, but I sometimes get impatient especially when it takes so much time to fix a problem which I think should be very easy to fix.

This impatience will be bolstered when it takes too long a time before I can be able to see whether the code I just wrote works or not :laughing: --- this is what they call a _slow feedback loop_.

A very long compilation time might be one of the reasons for a very slow feedback.

This problem can be solved if your system allows me to write fast (not slow) unit tests. So this will not be a problem if I can write fast unit tests.

If it takes a lot of time to compile your project, and you want me to be involved in that project, I would like to suggest to the team working on that project to give time to make the critical parts of that project to be unit testable, so that if there are bugs in those critical parts it will not take too much time to fix it.
 -->

<!-- 
If the unit tests of your system run very slow, you might be interested in hiring me to _help_ fix the running time of your unit tests. Please note that I used the word _"help"_ because I will be needing the help of _at least_ one of your developers who is already very familiar with the system whose unit tests' running time you want to fix. It might be possible for me to fix it alone, but it will take way too much time and will give me (and you) too much unecessary frustrations if you allow me to do it alone.
 -->



<!-- 
But, as every adult might have already realized, we do not always get justice in this life. So I intend to help those who experience injustice by helping them fix the mess that was the result of the original creators' abandonment of the system.

But if the creators of the system did not abandon their work, and is still working on it right now, and they know that their project is a mess but do not know how to fix it, I am also willing to _help_ clean up the mess.

I think I can help in fixing messy software... But I'm not [Micheal Feathers](https://www.bookdepository.com/Working-Effectively-with-Legacy-Code-Michael-Feathers/9780131177055?a_aid=jflaga), so if the mess is very big already, you might need someone more skillful than me to help fix it. If it is still small, I might be able to help.



You see, I believe in a personal Designer of the universe --- a Designer who is still cares about his creation (even though his creation do not seem to care about him)

But of course in the real world, that does not always happen.
-->



<!-- 
## **Cannot work on Android projects**

I cannot work on Android projects for my next job because I promised my current employer that I will not be working on an Android project in my next job.


## **Cannot work on Android projects, except...**

I cannot work on Android projects for my next job because I promised my current employer that I will not be working on an Android project in my next job... except when I will be hired in _helping_ decouple your business logic layer from the other parts of you software system, because in that case, I will not be _directly_ involved in working on the _Android-framework-specific_ parts of project.
 -->



<!--
## **I don't know how to do these CQRS and Event Sourcing things**

Even though I think this CQRS thing will have a very important role in software development in the next few years, I do not know how to do this yet. But I will learn about it after I finish the other things that I need to learn.
 -->



<!--
## **I know almost nothing about network programming**

I learned a little bit about this sockets thing in Uncle Bob Martin's ["The Craftsman Series"](/memorabilia/books/the-craftsman-series/), and the 1 hour video ["Network Programming Seminar"](http://cs50.tv/2007/fall/#about,seminars) of CS50 Fall 2007. I will learn more later if time permits.
-->



<!-- 
--------------------
 
<sup id="footnote-1">[[1]](#footnote-indicator-1)</sup> <small>_(I have already forgotten most things I read from this book. But if you have also read this book, you can use some quotes in it to correct me someday when I'm already working with you and I did something wrong. But, of course, if the quote you will use is in disagreement with some of my core values, then I might try to defend myself. :smile: I hope you will also listen during those times when I try to defend myself.)_</small>
 -->


<!--






### I'm the kind of person who is not comfortable accepting praise if I am not very confident about the project I'm working on. 


### Wehn I get frustrated

when i get frustrated I sometimes think this: let those who make the mess be the ones to clean the mess. DOn't let them work on new projects unless they first clean up the mess that they made. If you want other people to clean up the mess that someone else made, be sure to pay him more that what you paid the one who made the mess.






It gives me this feeling that the memebers of the team do not seem to care.

It would be great if your company have this kind of system where I can be able to voice my opinion, for example, when I see something that we are doing which is bad. 

This kind of system will breed trust to each member of the team...


I don't want to play the blaming game because I don't know what my coleauges, managers or employer in the past were experiencings when they decided to do things the way they did them.


If you want to hear examples about this please ask me during the interview.


I understand that there are times when I don't need to ask for permission when I do something which I think will benefit my employers or my coleagues, but I just don't want to play politics, so I have to ask for permission about these things before I get hired.


Examples:

not decoupled code that I need to test

using RxJava










### I almost wanted to give up on software development in the past

In my first job, I was very excited

  -  leaned about twitter ...


In my second job


So i will not work with you unless I'll be working in a new project where I will have influence about he structure/architecture of the project, or I will be working on an existing project that does not look like it was abandoned by it's designers, or I will be fixing an existing mess.... AND I can mentor the next person that will someday take care of the project I am currently working on (Or the current best designers in you company will mentor me)


Being influenced by people who promote DDD (Note: I only know a little about DDD), I already got past being a framework-focused developer to being a business-model-focused developer.

If your team is still in the stage of being framework-focused, I might not work well with them. Except maybe if you want someone to be influential into making your team business-focused.




### I have a hidden agenda

I want to help spread this idea of professionalism in the sovtware development comunity.



--------------------


**_If you are looking for my [Resum&eacute;](/resume/2019), you can view it [here](/resume/2019)_**



 -->